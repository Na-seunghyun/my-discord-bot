from keep_alive import keep_alive

import discord
from discord.ext import commands, tasks
from discord import app_commands
import re
import os
import random
import asyncio
import requests
import aiohttp
from collections import deque
from datetime import datetime, timedelta, timezone
from supabase import create_client, Client
import uuid  # uuid ì¶”ê°€

KST = timezone(timedelta(hours=9))

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

GUILD_ID = 1309433603331198977
MONITORED_CHANNEL_NAMES = [f"ì¼ë°˜{i}" for i in range(1, 17)] + ["í°ë§µ1", "í°ë§µ2"]

intents = discord.Intents.default()
intents.members = True
intents.voice_states = True

bot = commands.Bot(command_prefix="!", intents=intents)
tree = bot.tree
nickname_pattern = re.compile(r"^[ê°€-í£a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+/\d{2}$")
auto_disconnect_tasks = {}
voice_join_times = {}  # user_id: join_time


# ìë™ í‡´ì¥
async def auto_disconnect_after_timeout(user: discord.Member, channel: discord.VoiceChannel, timeout=1200):
    await asyncio.sleep(timeout)
    if user.voice and user.voice.channel == channel:
        try:
            await user.move_to(None)
            text_channel = discord.utils.get(user.guild.text_channels, name="ììœ ì±„íŒ…ë°©")
            if text_channel:
                await text_channel.send(f"{user.mention} ë‹˜, 20ë¶„ ì§€ë‚˜ì„œ ìë™ í‡´ì¥ë‹¹í–ˆì–´ìš”. ğŸš")
        except Exception as e:
            print(f"ì˜¤ë¥˜: {e}")
    auto_disconnect_tasks.pop(user.id, None)


def sql_escape(s):
    if s is None:
        return 'NULL'
    return "'" + str(s).replace("'", "''") + "'"

streaming_members = set()

# ì „ì—­ ìºì‹œ ì„ ì–¸ (í•¨ìˆ˜ ë°–, íŒŒì¼ ìµœìƒë‹¨)
waiting_room_message_cache = {}

from datetime import datetime, timezone, timedelta

# voice_activity ì¤‘ë³µ ì €ì¥ ë°©ì§€ìš© ìºì‹œ (ìœ ì €ë³„ ë§ˆì§€ë§‰ ì €ì¥ ì‹œê°„)
voice_activity_cache = {}

channel_last_empty = {}
all_empty_since = None
notified_after_empty = False


@bot.event
async def on_voice_state_update(member, before, after):
    global streaming_members
    global all_empty_since, notified_after_empty

    print(f"Voice state update - member: {member}, before: {before.channel if before else None}, after: {after.channel if after else None}")
    if member.bot:
        return

    # ìë™ í‡´ì¥ íƒ€ì´ë¨¸ ì œê±°
    if member.id in auto_disconnect_tasks:
        auto_disconnect_tasks[member.id].cancel()
        auto_disconnect_tasks.pop(member.id, None)

    # ëŒ€ê¸°ë°© ì…ì¥ ë©”ì‹œì§€ ì¤‘ë³µ ë°©ì§€ ìºì‹œ
    now_utc = datetime.utcnow()

    if (before.channel != after.channel) and (after.channel is not None):
        if after.channel.name == "ëŒ€ê¸°ë°©":
            last_sent = waiting_room_message_cache.get(member.id)
            if not last_sent or (now_utc - last_sent) > timedelta(seconds=30):
                text_channel = discord.utils.get(member.guild.text_channels, name="ììœ ì±„íŒ…ë°©")
                if text_channel:
                    await text_channel.send(f"{member.mention} ë‚˜ë„ ê²Œì„í•˜ê³ ì‹¶ì–´! ë‚˜ ë„ ë¼ ì›Œ ì¤˜!")
                    waiting_room_message_cache[member.id] = now_utc

    # ===== ìˆ˜ì •ëœ ë°°ê·¸ ì±„ë„ ì²« ì…ì¥ ê°ì§€ ë¡œì§ =====
    now = datetime.now(timezone.utc)
    guild = member.guild
    monitored_channels = [ch for ch in guild.voice_channels if ch.name in MONITORED_CHANNEL_NAMES]

    # ëª¨ë“  ëª¨ë‹ˆí„°ë§ ì±„ë„ì´ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
    all_empty = all(len(ch.members) == 0 for ch in monitored_channels)

    # í‡´ì¥ìœ¼ë¡œ ì¸í•´ ë§ˆì§€ë§‰ ì¸ì›ì´ ë‚˜ê°€ì„œ ëª¨ë“  ì±„ë„ì´ ë¹„ê²Œ ë˜ì—ˆì„ ê²½ìš°
    if before.channel and before.channel.name in MONITORED_CHANNEL_NAMES:
        if all_empty:
            if all_empty_since is None:
                all_empty_since = now
                notified_after_empty = False
                print(f"âš ï¸ ëª¨ë“  ëª¨ë‹ˆí„°ë§ ì±„ë„ ë¹„ì–´ìˆìŒ - ì‹œê°„ ê¸°ë¡ ì‹œì‘: {all_empty_since.isoformat()}")

    # ì…ì¥ ì‹œì ì—ë§Œ ì•„ë˜ ë©”ì‹œì§€ ì²´í¬
    if before.channel is None and after.channel and after.channel.name in MONITORED_CHANNEL_NAMES:
        if all_empty_since and (now - all_empty_since).total_seconds() >= 3600 and not notified_after_empty:
            text_channel = discord.utils.get(guild.text_channels, name="ììœ ì±„íŒ…ë°©")
            if text_channel:
                embed = discord.Embed(
                    title="ğŸš€ ì²« ë°°ê·¸ í¬ë¬¸ì´ ì—´ë¦½ë‹ˆë‹¤!",
                    description=(
                        f"{member.mention} ë‹˜ì´ ì²« ë°°ê·¸ í¬ë¬¸ì„ ì—´ë ¤ê³  í•©ë‹ˆë‹¤.\n\n"
                        "ê°™ì´ í•´ì£¼ì‹¤ ì¸ì›ë“¤ì€ í˜„ì‹œê°„ ë¶€ë¡œ G-pop ë°”ëë‹ˆë‹¤."
                    ),
                    color=discord.Color.blue()
                )
                await text_channel.send(content='@everyone', embed=embed)
                print("ğŸ“¢ G-pop ì•ˆë‚´ ë©”ì‹œì§€ ì „ì†¡ë¨ âœ…")
            notified_after_empty = True

    # ëª¨ë‹ˆí„°ë§ ì±„ë„ì— ì‚¬ëŒì´ ì¡´ì¬í•˜ë©´ ìƒíƒœ ì´ˆê¸°í™”
    if not all_empty:
        all_empty_since = None
        notified_after_empty = False
    # ===== ì—¬ê¸°ê¹Œì§€ ìˆ˜ì •ëœ ë¶€ë¶„ =====

    # ì…ì¥ ê¸°ë¡
    if before.channel is None and after.channel is not None:
        voice_join_times[member.id] = datetime.now(timezone.utc).replace(microsecond=0)

    # í‡´ì¥ ê¸°ë¡
    elif before.channel is not None and after.channel is None:
        join_time = voice_join_times.pop(member.id, None)
        if join_time:
            left_time = datetime.now(timezone.utc).replace(microsecond=0)
            duration = int((left_time - join_time).total_seconds())

            # âœ… ì±„ë„ì´ ì™„ì „íˆ ë¹„ì—ˆìœ¼ë©´ ì‹œê°„ ê¸°ë¡
            if before.channel and len(before.channel.members) == 0:
                channel_last_empty[before.channel.id] = left_time
                print(f"ğŸ“Œ '{before.channel.name}' ì±„ë„ì´ ë¹„ì—ˆìŒ â€” ì‹œê°„ ê¸°ë¡ë¨")

            # ì¤‘ë³µ ì €ì¥ ë°©ì§€ ì²´í¬
            last_save_time = voice_activity_cache.get(member.id)
            if last_save_time and (left_time - last_save_time) < timedelta(seconds=3):
                print(f"ì¤‘ë³µ ì €ì¥ ë°©ì§€: {member.id} - ìµœê·¼ ì €ì¥ ì‹œê°„ {last_save_time}")
                return

            user_id = str(member.id)
            username = member.display_name
            joined_at = join_time.isoformat()
            left_at = left_time.isoformat()

            data = {
                "user_id": user_id,
                "username": username,
                "joined_at": joined_at,
                "left_at": left_at,
                "duration_sec": duration,
            }

            try:
                response = supabase.table("voice_activity").insert(data).execute()
                if response.data:
                    print("âœ… DB ì €ì¥ ì„±ê³µ")
                    voice_activity_cache[member.id] = left_time  # ì €ì¥ ì‹œê°„ ì—…ë°ì´íŠ¸
                else:
                    print("âš ï¸ DB ì €ì¥ ì‹¤íŒ¨: ì‘ë‹µì— ë°ì´í„° ì—†ìŒ")
            except Exception as e:
                print(f"âŒ Supabase ì˜ˆì™¸ ë°œìƒ: {e}")

    # â€”â€”â€” ë°©ì†¡ ì‹œì‘/ì¢…ë£Œ ì•Œë¦¼ ì²˜ë¦¬ â€”â€”â€”

    # ë°©ì†¡ ì‹œì‘ ê°ì§€ (False -> True)
    if not before.self_stream and after.self_stream and after.channel is not None:
        if member.id not in streaming_members:
            streaming_members.add(member.id)
            text_channel = discord.utils.get(member.guild.text_channels, name="ììœ ì±„íŒ…ë°©")
            if text_channel:
                embed = discord.Embed(
                    title="ğŸ“º ë°©ì†¡ ì‹œì‘ ì•Œë¦¼!",
                    description=f"{member.mention} ë‹˜ì´ `{after.channel.name}` ì±„ë„ì—ì„œ ë°©ì†¡ì„ ì‹œì‘í–ˆì–´ìš”!\nğŸ‘€ ëª¨ë‘ êµ¬ê²½í•˜ëŸ¬ ê°€ë³´ì„¸ìš”!",
                    color=discord.Color.green()
                )
                embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
                embed.set_footer(text="Go Live í™œì„±í™”ë¨")
                await text_channel.send(embed=embed)

    # ë°©ì†¡ ì¢…ë£Œ ê°ì§€ (True -> False)
    if before.self_stream and not after.self_stream:
        if member.id in streaming_members:
            streaming_members.remove(member.id)
        # ë°©ì†¡ ì¢…ë£Œ ì•Œë¦¼ ë©”ì‹œì§€ëŠ” ë³´ë‚´ì§€ ì•ŠìŠµë‹ˆë‹¤!


@tasks.loop(minutes=30)
async def check_voice_channels_for_streaming():
    for guild in bot.guilds:
        text_channel = discord.utils.get(guild.text_channels, name="ììœ ì±„íŒ…ë°©")
        if not text_channel:
            continue

        for vc in guild.voice_channels:
            if vc.name in MONITORED_CHANNEL_NAMES and vc.members:
                non_bot_members = [m for m in vc.members if not m.bot]
                if not any(m.voice and m.voice.self_stream for m in non_bot_members):
                    mentions = " ".join(m.mention for m in non_bot_members)

                    embed = discord.Embed(
                        title="ğŸš¨ ë°©ì†¡ êº¼ì§ ê°ì§€",
                        description=f"`{vc.name}` ì±„ë„ì— ì‚¬ëŒì´ ìˆì§€ë§Œ **Go Live ë°©ì†¡ì´ êº¼ì ¸ ìˆìŠµë‹ˆë‹¤.**",
                        color=discord.Color.red()
                    )
                    embed.add_field(name="í˜„ì¬ ì¸ì›", value=f"{len(non_bot_members)}ëª…", inline=True)
                    embed.add_field(name="ë¼ì´ë¸Œ ìƒíƒœ", value="âŒ ì—†ìŒ", inline=True)
                    embed.set_footer(text="ì‹¤ìˆ˜ë¡œ êº¼ì¡Œë‹¤ë©´ ë‹¤ì‹œ ë°©ì†¡ì„ ì¼œì£¼ì„¸ìš”! ğŸ¥")

                    await text_channel.send(content=mentions, embed=embed)


@tree.command(name="ë„ì›€ë§", description="ë´‡ ëª…ë ¹ì–´ ë° ê¸°ëŠ¥ ì•ˆë‚´", guild=discord.Object(id=GUILD_ID))
async def ë„ì›€ë§(interaction: discord.Interaction):
    embed = discord.Embed(
        title="ğŸ¤– ë´‡ ëª…ë ¹ì–´ ì•ˆë‚´",
        description="ì„œë²„ ê´€ë¦¬ì™€ ìŒì„±ì±„ë„ í™œë™ì„ ë„ì™€ì£¼ëŠ” ëª…ë ¹ì–´ ëª©ë¡ì…ë‹ˆë‹¤.",
        color=discord.Color.blue()
    )

    embed.add_field(
        name="ğŸ“¢ /ì†Œí™˜",
        value=(
            "ì„ íƒí•œ ìŒì„± ì±„ë„ì˜ ì¸ì›ë“¤ì„ **ë‚´ê°€ ìˆëŠ” ì±„ë„ë¡œ ì†Œí™˜**í•©ë‹ˆë‹¤.\n"
            "`all` ì„ íƒ ì‹œ `ë°¥ì¢€ë¬µê² ìŠµë‹ˆë‹¤`, `ì‰¼í„°`, `í´ëœí›ˆë ¨ì†Œ`ëŠ” ì œì™¸ë©ë‹ˆë‹¤."
        ),
        inline=False
    )

    embed.add_field(
        name="ğŸ² /íŒ€ì§œê¸°",
        value=(
            "í˜„ì¬ ìŒì„± ì±„ë„ ì¸ì›ì„ íŒ€ìœ¼ë¡œ ë‚˜ëˆ„ê³ , **ë¹ˆ ì¼ë°˜ ì±„ë„ë¡œ ìë™ ë¶„ë°°**í•©ë‹ˆë‹¤.\n"
            "ì˜ˆ: íŒ€ë‹¹ 3ëª…ì”© ëœë¤ìœ¼ë¡œ ë‚˜ëˆ  ì¼ë°˜1, ì¼ë°˜2ë¡œ ì´ë™"
        ),
        inline=False
    )

    embed.add_field(
        name="ğŸš /ë°¥",
        value=(
            "`ë°¥ì¢€ë¬µê² ìŠµë‹ˆë‹¤` ì±„ë„ë¡œ ìì‹ ì„ ì´ë™ì‹œí‚µë‹ˆë‹¤.\n"
            "20ë¶„ ì´ìƒ í™œë™ì´ ì—†ìœ¼ë©´ ìë™ í‡´ì¥ë©ë‹ˆë‹¤."
        ),
        inline=False
    )

    embed.add_field(
        name="ğŸ§ª /ê²€ì‚¬",
        value=(
            "ì„œë²„ ë©¤ë²„ë“¤ì˜ **ë‹‰ë„¤ì„ í˜•ì‹ì„ ê²€ì‚¬**í•©ë‹ˆë‹¤.\n"
            "ì˜¬ë°”ë¥¸ ë‹‰ë„¤ì„: `ì´ë¦„/ID/ë‘ìë¦¬ìˆ«ì`"
        ),
        inline=False
    )

    embed.add_field(
        name="ğŸ“ˆ /ì ‘ì†ì‹œê°„ë­í‚¹",
        value=(
            "ìŒì„± ì±„ë„ì—ì„œ í™œë™í•œ **ì ‘ì† ì‹œê°„ Top 10 ë­í‚¹**ì„ í™•ì¸í•©ë‹ˆë‹¤.\n"
            "ë²„íŠ¼ í´ë¦­ ì‹œ ì ‘ì† ì‹œê°„ í™•ì¸ ê°€ëŠ¥"
        ),
        inline=False
    )

    embed.add_field(
        name="ğŸ¯ /ê°œë³„ì†Œí™˜",
        value=(
            "ìŒì„± ì±„ë„ì— ìˆëŠ” ë©¤ë²„ë¥¼ ê³¨ë¼ì„œ **ë‚´ê°€ ìˆëŠ” ì±„ë„ë¡œ ì†Œí™˜**í•©ë‹ˆë‹¤.\n"
            "ì—¬ëŸ¬ ë©¤ë²„ ì„ íƒ ê°€ëŠ¥"
        ),
        inline=False
    )

    embed.set_footer(text="ê¸°íƒ€ ë¬¸ì˜ëŠ” ê´€ë¦¬ìì—ê²Œ DM ì£¼ì„¸ìš”!")
    await interaction.response.send_message(embed=embed, ephemeral=True)



# âœ… ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´: ì „ì ì¡°íšŒ
import discord
import requests
import os
import json
import random
from datetime import datetime, timedelta

# API ë° ë””ìŠ¤ì½”ë“œ ê¸°ë³¸ ì„¤ì •
API_KEY = os.environ.get("PUBG_API_KEY")
PLATFORM = "kakao"

headers = {
    "Authorization": f"Bearer {API_KEY}",
    "Accept": "application/vnd.api+json"
}

RATE_LIMIT = 10
RATE_LIMIT_INTERVAL = 60
_last_requests = []

# âœ… JSON í”¼ë“œë°± ë¡œë”©
with open("feedback_data/pubg_feedback_full.json", "r", encoding="utf-8") as f:
    feedback_json = json.load(f)

def can_make_request():
    now = datetime.now()
    global _last_requests
    _last_requests = [t for t in _last_requests if (now - t).total_seconds() < RATE_LIMIT_INTERVAL]
    return len(_last_requests) < RATE_LIMIT

def register_request():
    global _last_requests
    _last_requests.append(datetime.now())

def get_player_id(player_name):
    url = f"https://api.pubg.com/shards/{PLATFORM}/players?filter[playerNames]={player_name}"
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    data = response.json()
    return data["data"][0]["id"]

def get_season_id():
    url = f"https://api.pubg.com/shards/{PLATFORM}/seasons"
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    data = response.json()
    for season in data["data"]:
        if season["attributes"]["isCurrentSeason"]:
            return season["id"]

def get_player_stats(player_id, season_id):
    url = f"https://api.pubg.com/shards/{PLATFORM}/players/{player_id}/seasons/{season_id}"
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    return response.json()

# âœ… ìŠ¤ì¿¼ë“œ ì „ì ë§Œ í”¼ë“œë°±ìš©ìœ¼ë¡œ ì¶”ì¶œ
def extract_squad_metrics(stats):
    mode_stats = stats["data"]["attributes"]["gameModeStats"].get("squad")
    if not mode_stats or mode_stats["roundsPlayed"] == 0:
        return None, "âŒ ìŠ¤ì¿¼ë“œ ëª¨ë“œ ì „ì ì´ ì—†ì–´ ë¶„ì„ í”¼ë“œë°±ì„ ì œê³µí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

    rounds = mode_stats['roundsPlayed']
    wins = mode_stats['wins']
    kills = mode_stats['kills']
    damage = mode_stats['damageDealt']
    avg_damage = damage / rounds
    kd = kills / max(1, rounds - wins)
    win_rate = (wins / rounds) * 100

    return (avg_damage, kd, win_rate), None

# âœ… êµ¬ê°„ ë¶„ë¥˜ í•¨ìˆ˜
def get_damage_key(avg_damage):
    if avg_damage < 100: return "D0"
    elif avg_damage < 150: return "D1"
    elif avg_damage < 200: return "D2"
    elif avg_damage < 250: return "D3"
    elif avg_damage < 300: return "D4"
    elif avg_damage < 350: return "D5"
    elif avg_damage < 400: return "D6"
    elif avg_damage < 450: return "D7"
    elif avg_damage < 500: return "D8"
    else: return "D9"

def get_kd_key(kd):
    if kd < 0.3: return "K0"
    elif kd < 0.6: return "K1"
    elif kd < 1.0: return "K2"
    elif kd < 1.5: return "K3"
    elif kd < 2.0: return "K4"
    elif kd < 3.0: return "K5"
    elif kd < 5.0: return "K6"
    else: return "K7"

def get_winrate_key(win_rate):
    if win_rate == 0: return "W0"
    elif win_rate < 1: return "W1"
    elif win_rate < 3: return "W2"
    elif win_rate < 5: return "W3"
    elif win_rate < 7: return "W4"
    elif win_rate < 10: return "W5"
    elif win_rate < 15: return "W6"
    elif win_rate < 20: return "W7"
    elif win_rate < 30: return "W8"
    elif win_rate < 40: return "W9"
    elif win_rate < 50: return "W10"
    else: return "W11"

# âœ… êµ¬ê°„ ê¸°ë°˜ JSON í”¼ë“œë°± ë°˜í™˜
def detailed_feedback(avg_damage, kd, win_rate):
    dmg_key = get_damage_key(avg_damage)
    kd_key = get_kd_key(kd)
    win_key = get_winrate_key(win_rate)

    dmg_msg = random.choice(feedback_json["damage"][dmg_key])
    kd_msg = random.choice(feedback_json["kdr"][kd_key])
    win_msg = random.choice(feedback_json["winrate"][win_key])

    return (
        f"ğŸ“Š í‰ê·  ë°ë¯¸ì§€ í”¼ë“œë°±:\n{dmg_msg}\n\n"
        f"âš”ï¸ K/D í”¼ë“œë°±:\n{kd_msg}\n\n"
        f"ğŸ† ìŠ¹ë¥  í”¼ë“œë°±:\n{win_msg}"
    )


# âœ… ë””ìŠ¤ì½”ë“œ ë´‡ ì»¤ë§¨ë“œ

@tree.command(name="ì „ì ", description="PUBG ë‹‰ë„¤ì„ìœ¼ë¡œ ì „ì  ì¡°íšŒ", guild=discord.Object(id=GUILD_ID))
async def ì „ì (interaction: discord.Interaction, ë‹‰ë„¤ì„: str):
    await interaction.response.defer()

    if not can_make_request():
        await interaction.followup.send("âš ï¸ API ìš”ì²­ ì œí•œ(ë¶„ë‹¹ 10íšŒ)ìœ¼ë¡œ ì¸í•´ ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.", ephemeral=True)
        return

    try:
        register_request()
        player_id = get_player_id(ë‹‰ë„¤ì„)
        season_id = get_season_id()
        stats = get_player_stats(player_id, season_id)

        # ë¶„ì„ í”¼ë“œë°±
        squad_metrics, error = extract_squad_metrics(stats)
        if squad_metrics:
            avg_damage, kd, win_rate = squad_metrics
            feedback = detailed_feedback(avg_damage, kd, win_rate)
        else:
            feedback = error

        embed = discord.Embed(
            title=f"{ë‹‰ë„¤ì„}ë‹˜ì˜ PUBG ì „ì  ìš”ì•½",
            color=discord.Color.blue()
        )

        for mode in ["solo", "duo", "squad"]:
            mode_stats = stats["data"]["attributes"]["gameModeStats"].get(mode)
            if not mode_stats or mode_stats["roundsPlayed"] == 0:
                continue

            rounds = mode_stats['roundsPlayed']
            wins = mode_stats['wins']
            kills = mode_stats['kills']
            damage = mode_stats['damageDealt']
            avg_damage = damage / rounds
            kd = kills / max(1, rounds - wins)
            win_pct = (wins / rounds) * 100

            value = (
                f"ê²Œì„ ìˆ˜: {rounds}\n"
                f"ìŠ¹ë¦¬ ìˆ˜: {wins} ({win_pct:.2f}%)\n"
                f"í‚¬ ìˆ˜: {kills}\n"
                f"í‰ê·  ë°ë¯¸ì§€: {avg_damage:.2f}\n"
                f"K/D: {kd:.2f}"
            )
            embed.add_field(name=mode.upper(), value=value, inline=True)

        # í”¼ë“œë°± ë¬¸ìì—´ì„ ê° í•­ëª©ë³„ë¡œ ë‚˜ëˆ„ì–´ ê¾¸ë©°ì„œ ë„£ê¸°
        if squad_metrics:
            feedback_lines = feedback.split('\n\n')

            feedback_text = (
                f"**ğŸ“Š í‰ê·  ë°ë¯¸ì§€ í”¼ë“œë°±**\n"
                f"ğŸ’¥ {feedback_lines[0].replace('ğŸ“Š í‰ê·  ë°ë¯¸ì§€ í”¼ë“œë°±:\n', '')}\n\n"
                f"**âš”ï¸ K/D í”¼ë“œë°±**\n"
                f"ğŸ¯ {feedback_lines[1].replace('âš”ï¸ K/D í”¼ë“œë°±:\n', '')}\n\n"
                f"**ğŸ† ìŠ¹ë¥  í”¼ë“œë°±**\n"
                f"ğŸ”¥ {feedback_lines[2].replace('ğŸ† ìŠ¹ë¥  í”¼ë“œë°±:\n', '')}"
            )
        else:
            feedback_text = feedback

        embed.add_field(name="ğŸ“Š SQUAD ë¶„ì„ í”¼ë“œë°±", value=feedback_text, inline=False)
        embed.set_footer(text="PUBG API ì œê³µ")

        await interaction.followup.send(embed=embed)

    except requests.HTTPError as e:
        await interaction.followup.send(f"âŒ API ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}", ephemeral=True)
    except Exception as e:
        await interaction.followup.send(f"âŒ ì „ì  ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}", ephemeral=True)












# âœ… ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´: ê²€ì‚¬
@tree.command(name="ê²€ì‚¬", description="ë‹‰ë„¤ì„ ê²€ì‚¬", guild=discord.Object(id=GUILD_ID))
async def ê²€ì‚¬(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    count = 0
    for member in interaction.guild.members:
        if member.bot:
            continue
        parts = (member.nick or member.name).split("/")
        if len(parts) != 3 or not nickname_pattern.fullmatch("/".join(p.strip() for p in parts)):
            count += 1
            try:
                await interaction.channel.send(f"{member.mention} ë‹‰ë„¤ì„ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•„ìš”.")
            except:
                pass
    await interaction.followup.send(f"ğŸ” ê²€ì‚¬ ì™„ë£Œ: {count}ëª… ë¬¸ì œ ìˆìŒ", ephemeral=True)


# âœ… ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´: ì†Œí™˜


EXCLUDED_CHANNELS = ["ë°¥ì¢€ë¬µê² ìŠµë‹ˆë‹¤", "ì‰¼í„°", "í´ëœí›ˆë ¨ì†Œ"]

CHANNEL_CHOICES = [
    "all",
    "ë°¥ì¢€ë¬µê² ìŠµë‹ˆë‹¤", "ì‰¼í„°", "í´ëœí›ˆë ¨ì†Œ",
    "ê²ŒìŠ¤íŠ¸ë°©", "ëŒ€ê¸°ë°©",
    "í°ë§µ1", "í°ë§µ2"
] + [f"ì¼ë°˜{i}" for i in range(1, 17)]

# --- ì±„ë„ ì†Œí™˜ UI êµ¬ì„± ---
class ChannelSelect(discord.ui.Select):
    def __init__(self, view: 'ChannelSelectView'):
        self.parent_view = view
        options = [discord.SelectOption(label=ch) for ch in CHANNEL_CHOICES]
        super().__init__(
            placeholder="ì†Œí™˜í•  ì±„ë„ì„ ì„ íƒí•˜ì„¸ìš” (ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥)",
            min_values=1,
            max_values=len(options),
            options=options,
            row=0
        )

    async def callback(self, interaction: discord.Interaction):
        self.parent_view.selected_channels = self.values
        selected_str = ", ".join(self.values)
        await interaction.response.edit_message(
            content=f"ì„ íƒí•œ ì±„ë„: {selected_str}",
            view=self.parent_view
        )


class ChannelConfirmButton(discord.ui.Button):
    def __init__(self, view: 'ChannelSelectView'):
        super().__init__(label="âœ… ì†Œí™˜í•˜ê¸°", style=discord.ButtonStyle.green, row=1)
        self.parent_view = view

    async def callback(self, interaction: discord.Interaction):
        vc = interaction.user.voice.channel if interaction.user.voice else None
        if not vc:
            await interaction.response.send_message("âŒ ë¨¼ì € ìŒì„± ì±„ë„ì— ë“¤ì–´ê°€ì£¼ì„¸ìš”!", ephemeral=True)
            return

        selected = self.parent_view.selected_channels
        if not selected:
            await interaction.response.send_message("âš ï¸ ì±„ë„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.", ephemeral=True)
            return

        await interaction.response.defer(thinking=True)  # ì—¬ê¸°ì„œ 1íšŒ ì‘ë‹µ

        if "all" in selected:
            target_channels = [
                ch for ch in interaction.guild.voice_channels if ch.name not in EXCLUDED_CHANNELS
            ]
            excluded_note = "\n\nâ—ï¸`all` ì„ íƒ ì‹œ `ë°¥ì¢€ë¬µê² ìŠµë‹ˆë‹¤`, `ì‰¼í„°`, `í´ëœí›ˆë ¨ì†Œ`ëŠ” ì œì™¸ë©ë‹ˆë‹¤."
        else:
            target_channels = [
                ch for ch in interaction.guild.voice_channels if ch.name in selected
            ]
            excluded_note = ""

        moved = 0
        for ch in target_channels:
            for member in ch.members:
                if not member.bot:
                    try:
                        await member.move_to(vc)
                        moved += 1
                        await asyncio.sleep(0.5)
                    except Exception as e:
                        print(f"âŒ {member.display_name} ì´ë™ ì‹¤íŒ¨: {e}")

        if moved == 0:
            await interaction.followup.send("âš ï¸ ì´ë™í•  ë©¤ë²„ê°€ ì—†ìŠµë‹ˆë‹¤.", ephemeral=True)
        else:
            embed = discord.Embed(
                title="ğŸ“¢ ì¿ ì¹˜ìš”ì„¸ë…¸ì¥¬ì¸  !",
                description=f"{interaction.user.mention} ë‹˜ì´ **{moved}ëª…**ì„ ìŒì„±ì±„ë„ë¡œ ì†Œí™˜í–ˆìŠµë‹ˆë‹¤.{excluded_note}",
                color=discord.Color.green()
            )
            embed.set_image(url="https://raw.githubusercontent.com/Na-seunghyun/my-discord-bot/main/123123.gif")
            await interaction.followup.send(embed=embed, ephemeral=False)

        self.parent_view.stop()
        try:
            await interaction.message.edit(view=None)
        except discord.NotFound:
            pass


class ChannelSelectView(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=60)
        self.selected_channels: list[str] = []
        self.add_item(ChannelSelect(self))
        self.add_item(ChannelConfirmButton(self))


# --- ë©¤ë²„ ì†Œí™˜ UI êµ¬ì„± ---
class MemberSelect(discord.ui.Select):
    def __init__(self, members: list[discord.Member], view: 'MemberSelectView'):
        self.parent_view = view
        options = [
            discord.SelectOption(label=m.display_name, value=str(m.id))
            for m in members if not m.bot
        ]
        super().__init__(
            placeholder="ì†Œí™˜í•  ë©¤ë²„ë¥¼ ì„ íƒí•˜ì„¸ìš” (ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥)",
            min_values=1,
            max_values=min(25, len(options)),
            options=options,
            row=0
        )

    async def callback(self, interaction: discord.Interaction):
        self.parent_view.selected_member_ids = [int(v) for v in self.values]
        selected_names = [option.label for option in self.options if option.value in self.values]
        selected_str = ", ".join(selected_names)
        await interaction.response.edit_message(
            content=f"ì„ íƒí•œ ë©¤ë²„: {selected_str}",
            view=self.parent_view
        )


class MemberConfirmButton(discord.ui.Button):
    def __init__(self, view: 'MemberSelectView'):
        super().__init__(label="âœ… ì†Œí™˜í•˜ê¸°", style=discord.ButtonStyle.green, row=1)
        self.parent_view = view

    async def callback(self, interaction: discord.Interaction):
        vc = interaction.user.voice.channel if interaction.user.voice else None
        if not vc:
            await interaction.response.send_message("âŒ ë¨¼ì € ìŒì„± ì±„ë„ì— ë“¤ì–´ê°€ì£¼ì„¸ìš”!", ephemeral=True)
            return

        selected_ids = self.parent_view.selected_member_ids
        if not selected_ids:
            await interaction.response.send_message("âš ï¸ ë©¤ë²„ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.", ephemeral=True)
            return

        await interaction.response.defer(thinking=True)  # 1íšŒ ì‘ë‹µ

        moved = 0
        for member_id in selected_ids:
            member = interaction.guild.get_member(member_id)
            if member and member.voice and member.voice.channel != vc and not member.bot:
                try:
                    await member.move_to(vc)
                    moved += 1
                    await asyncio.sleep(0.5)
                except Exception as e:
                    print(f"âŒ {member.display_name} ì´ë™ ì‹¤íŒ¨: {e}")

        if moved == 0:
            await interaction.followup.send("âš ï¸ ì´ë™í•  ë©¤ë²„ê°€ ì—†ìŠµë‹ˆë‹¤.", ephemeral=True)
        else:
            embed = discord.Embed(
                title="ğŸ“¢ ì¿ ì¹˜ìš”ì„¸ë…¸ì¥¬ì¸  !",
                description=f"{interaction.user.mention} ë‹˜ì´ **{moved}ëª…**ì„ ìŒì„±ì±„ë„ë¡œ ì†Œí™˜í–ˆìŠµë‹ˆë‹¤.",
                color=discord.Color.green()
            )
            embed.set_image(url="https://raw.githubusercontent.com/Na-seunghyun/my-discord-bot/main/123123.gif")
            await interaction.followup.send(embed=embed, ephemeral=False)

        self.parent_view.stop()
        try:
            await interaction.message.edit(view=None)
        except discord.NotFound:
            pass


class MemberSelectView(discord.ui.View):
    def __init__(self, members: list[discord.Member]):
        super().__init__(timeout=60)
        self.selected_member_ids: list[int] = []
        self.add_item(MemberSelect(members, self))
        self.add_item(MemberConfirmButton(self))


# --- ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´ ë“±ë¡ ---
@tree.command(name="ì†Œí™˜", description="ìŒì„± ì±„ë„ ì¸ì› ì†Œí™˜", guild=discord.Object(id=GUILD_ID))
async def ì†Œí™˜(interaction: discord.Interaction):
    await interaction.response.send_message("ì†Œí™˜í•  ì±„ë„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.", view=ChannelSelectView(), ephemeral=True)


@tree.command(name="ê°œë³„ì†Œí™˜", description="íŠ¹ì • ë©¤ë²„ë¥¼ ì„ íƒí•´ ì†Œí™˜í•©ë‹ˆë‹¤.", guild=discord.Object(id=GUILD_ID))
async def ê°œë³„ì†Œí™˜(interaction: discord.Interaction):
    # 1. ìŒì„±ì±„ë„ ì…ì¥ í™•ì¸
    vc = interaction.user.voice.channel if interaction.user.voice else None
    if not vc:
        # ì‘ë‹µ ì—¬ë¶€ ì²´í¬ í›„ ì‘ë‹µ
        if not interaction.response.is_done():
            await interaction.response.send_message("âŒ ìŒì„± ì±„ë„ì— ë“¤ì–´ê°€ì£¼ì„¸ìš”!", ephemeral=True)
        return

    # 2. ë©¤ë²„ í•„í„°ë§
    members = [m for m in interaction.guild.members if m.voice and m.voice.channel and not m.bot]
    if not members:
        if not interaction.response.is_done():
            await interaction.response.send_message("âš ï¸ ìŒì„±ì±„ë„ì— ìˆëŠ” ë©¤ë²„ê°€ ì—†ìŠµë‹ˆë‹¤.", ephemeral=True)
        return

    # 3. View ìƒì„±
    view = MemberSelectView(members)

    # 4. interaction ì‘ë‹µ ì‹œë„ (ì¤‘ë³µì‘ë‹µ ë°©ì§€)
    if not interaction.response.is_done():
        try:
            await interaction.response.send_message("ì†Œí™˜í•  ë©¤ë²„ë¥¼ ì„ íƒí•˜ì„¸ìš”:", view=view, ephemeral=True)
        except discord.errors.InteractionResponded:
            # ì´ë¯¸ ì‘ë‹µí–ˆìœ¼ë©´ ë¬´ì‹œ ë˜ëŠ” ë¡œê¹…
            print("interaction already responded")
    else:
        # ì´ë¯¸ ì‘ë‹µí–ˆìœ¼ë©´ followup ë³´ë‚´ê¸° (í•„ìš” ì‹œ)
        await interaction.followup.send("ì†Œí™˜í•  ë©¤ë²„ë¥¼ ì„ íƒí•˜ì„¸ìš”:", view=view, ephemeral=True)







    

    # ì„œë²„ ë©¤ë²„ ì¤‘ ìŒì„±ì±„ë„ì— ë“¤ì–´ì™€ìˆëŠ” ë©¤ë²„ë§Œ í•„í„°ë§ (ë´‡ ì œì™¸)
    members = [m for m in interaction.guild.members if m.voice and m.voice.channel and not m.bot]

    if not members:
        await interaction.response.send_message("âš ï¸ ìŒì„±ì±„ë„ì— ìˆëŠ” ë©¤ë²„ê°€ ì—†ìŠµë‹ˆë‹¤.", ephemeral=True)
        return

    view = MemberSelectView(members)
    await interaction.response.send_message("ì†Œí™˜í•  ë©¤ë²„ë¥¼ ì„ íƒí•˜ì„¸ìš”:", view=view, ephemeral=True)


# âœ… ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´: íŒ€ì§œê¸°
class TeamMoveView(discord.ui.View):
    def __init__(self, teams, empty_channels, origin_channel):
        super().__init__(timeout=None)
        self.teams = teams
        self.empty_channels = empty_channels
        self.origin_channel = origin_channel
        self.moved = False

    @discord.ui.button(label="ğŸš€ íŒ€ ì´ë™ ì‹œì‘", style=discord.ButtonStyle.green)
    async def move(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.moved:
            await interaction.response.send_message("ì´ë¯¸ ì´ë™ ì™„ë£Œë¨", ephemeral=True)
            return
        for team, channel in zip(self.teams[1:], self.empty_channels):
            for member in team:
                try:
                    await member.move_to(channel)
                except:
                    pass
        self.moved = True
        button.disabled = True
        await interaction.response.edit_message(view=self)
        self.stop()


@tree.command(name="íŒ€ì§œê¸°", description="ìŒì„± ì±„ë„ íŒ€ ë‚˜ëˆ„ê¸°", guild=discord.Object(id=GUILD_ID))
@app_commands.describe(team_size="íŒ€ë‹¹ ì¸ì› ìˆ˜")
@app_commands.choices(team_size=[
    app_commands.Choice(name="2", value=2),
    app_commands.Choice(name="3", value=3),
    app_commands.Choice(name="4", value=4),
])
async def íŒ€ì§œê¸°(interaction: discord.Interaction, team_size: app_commands.Choice[int]):
    vc = interaction.user.voice.channel if interaction.user.voice else None
    if not vc:
        await interaction.response.send_message("âŒ ìŒì„± ì±„ë„ì— ë¨¼ì € ë“¤ì–´ê°€ ì£¼ì„¸ìš”!", ephemeral=True)
        return

    members = [m for m in vc.members if not m.bot]
    random.shuffle(members)
    teams = [members[i:i + team_size.value] for i in range(0, len(members), team_size.value)]

    guild = interaction.guild
    empty_channels = [ch for ch in guild.voice_channels if ch.name.startswith("ì¼ë°˜") and len(ch.members) == 0 and ch != vc]

    if len(empty_channels) < len(teams) - 1:
        await interaction.response.send_message("âŒ ë¹ˆ ì±„ë„ ë¶€ì¡±", ephemeral=True)
        return

    msg = f"ğŸ² íŒ€ ë‚˜ëˆ„ê¸° ì™„ë£Œ\n\n**íŒ€ 1 (í˜„ì¬ ì±„ë„):** {', '.join(m.display_name for m in teams[0])}\n"
    for idx, (team, ch) in enumerate(zip(teams[1:], empty_channels), start=2):
        msg += f"**íŒ€ {idx} ({ch.name}):** {', '.join(m.display_name for m in team)}\n"

    await interaction.response.send_message(msg, view=TeamMoveView(teams, empty_channels, vc))


# âœ… ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´: ë°¥
@tree.command(name="ë°¥", description="ë°¥ì¢€ë¬µê² ìŠµë‹ˆë‹¤ ì±„ë„ë¡œ ì´ë™", guild=discord.Object(id=GUILD_ID))
async def ë°¥(interaction: discord.Interaction):
    user = interaction.user
    guild = interaction.guild
    vc = discord.utils.get(guild.voice_channels, name="ë°¥ì¢€ë¬µê² ìŠµë‹ˆë‹¤")
    if not vc:
        await interaction.response.send_message("âŒ ì±„ë„ ì—†ìŒ", ephemeral=True)
        return
    try:
        await user.move_to(vc)
        await interaction.response.send_message("ğŸš ë°¥ ì±„ë„ë¡œ ì´ë™ ì™„ë£Œ", ephemeral=True)

        task = asyncio.create_task(auto_disconnect_after_timeout(user, vc, timeout=1200))
        auto_disconnect_tasks[user.id] = task
    except:
        await interaction.response.send_message("âŒ ì´ë™ ì‹¤íŒ¨", ephemeral=True)


# â€”â€”â€” ì—¬ê¸°ë¶€í„° ì¶”ê°€ â€”â€”â€”
def format_duration(seconds: int) -> str:
    days, remainder = divmod(seconds, 86400)  # 86400ì´ˆ = 1ì¼
    hours, remainder = divmod(remainder, 3600)
    minutes, seconds = divmod(remainder, 60)

    parts = []
    if days > 0:
        parts.append(f"{days}ì¼")
    if hours > 0 or days > 0:
        parts.append(f"{hours}ì‹œê°„")
    if minutes > 0 or hours > 0 or days > 0:
        parts.append(f"{minutes}ë¶„")
    parts.append(f"{seconds}ì´ˆ")

    return " ".join(parts)


from discord.ui import View, button


class VoiceTopButton(View):
    def __init__(self):
        super().__init__(timeout=180)  # ë·° íƒ€ì„ì•„ì›ƒ 3ë¶„

    @button(label="ì ‘ì†ì‹œê°„ë­í‚¹ ë³´ê¸°", style=discord.ButtonStyle.primary)
    async def on_click(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=False)

        try:
            response = supabase.rpc("get_top_voice_activity", {}).execute()

            if not hasattr(response, "data") or response.data is None:
                await interaction.followup.send("âŒ Supabase ì‘ë‹µ ì˜¤ë¥˜ ë˜ëŠ” ë°ì´í„° ì—†ìŒ", ephemeral=False)
                return

            data = response.data
            if not data:
                await interaction.followup.send("ğŸ˜¥ ê¸°ë¡ëœ ì ‘ì† ì‹œê°„ì´ ì—†ìŠµë‹ˆë‹¤.", ephemeral=False)
                return

            msg = "ğŸ¤ ìŒì„± ì ‘ì†ì‹œê°„ Top 10\n"
            for rank, info in enumerate(data, 1):
                time_str = format_duration(info['total_duration'])
                msg += f"{rank}. {info['username']} â€” {time_str}\n"

            button.disabled = True
            try:
                await interaction.message.edit(view=self)
            except discord.errors.NotFound:
                print("âš ï¸ í¸ì§‘í•  ë©”ì‹œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

            await interaction.followup.send(msg, ephemeral=False)

        except Exception as e:
            await interaction.followup.send(f"â— ì˜¤ë¥˜ ë°œìƒ: {e}", ephemeral=False)


@tree.command(name="ì ‘ì†ì‹œê°„ë­í‚¹", description="ìŒì„± ì ‘ì†ì‹œê°„ Top 10", guild=discord.Object(id=GUILD_ID))
async def ì ‘ì†ì‹œê°„ë­í‚¹(interaction: discord.Interaction):
    # 1) ì¦‰ì‹œ defer â€” followup ìœ¼ë¡œ ë²„íŠ¼ ë©”ì‹œì§€ ì „ì†¡ ì¤€ë¹„
    await interaction.response.defer(ephemeral=True)
    # 2) ë²„íŠ¼ ë©”ì‹œì§€ëŠ” followup.send ë¡œ
    await interaction.followup.send(
        "ë²„íŠ¼ì„ ëˆŒëŸ¬ ìŒì„± ì ‘ì†ì‹œê°„ ë­í‚¹ì„ í™•ì¸í•˜ì„¸ìš”.",
        view=VoiceTopButton(),
        ephemeral=True
    )


@bot.event
async def on_ready():
    guild = discord.Object(id=GUILD_ID)
    await tree.sync(guild=guild)
    check_voice_channels_for_streaming.start()
    print(f"âœ… ë´‡ ë¡œê·¸ì¸: {bot.user}")


keep_alive()

TOKEN = os.getenv("DISCORD_TOKEN")
if TOKEN:
    bot.run(TOKEN)
else:
    print("âŒ í™˜ê²½ë³€ìˆ˜ DISCORD_TOKENì´ ì—†ìŠµë‹ˆë‹¤.")
