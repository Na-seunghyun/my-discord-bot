from keep_alive import keep_alive

import discord
from discord.ext import commands, tasks
from discord import app_commands
import re
import os
import random
import asyncio
from datetime import datetime, timezone

from supabase import create_client, Client

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

GUILD_ID = 1309433603331198977
MONITORED_CHANNEL_NAMES = [f"ì¼ë°˜{i}" for i in range(1, 17)] + ["í°ë§µ1", "í°ë§µ2"]

intents = discord.Intents.default()
intents.members = True
intents.voice_states = True

bot = commands.Bot(command_prefix="!", intents=intents)
tree = bot.tree
nickname_pattern = re.compile(r"^[ê°€-í£a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+/\d{2}$")
auto_disconnect_tasks = {}
voice_join_times = {}  # user_id: join_time


# ìë™ í‡´ì¥
async def auto_disconnect_after_timeout(user: discord.Member, channel: discord.VoiceChannel, timeout=1200):
    await asyncio.sleep(timeout)
    if user.voice and user.voice.channel == channel:
        try:
            await user.move_to(None)
            text_channel = discord.utils.get(user.guild.text_channels, name="ììœ ì±„íŒ…ë°©")
            if text_channel:
                await text_channel.send(f"{user.mention} ë‹˜, 20ë¶„ ì§€ë‚˜ì„œ ìë™ í‡´ì¥ë‹¹í–ˆì–´ìš”. ğŸš")
        except Exception as e:
            print(f"ì˜¤ë¥˜: {e}")
    auto_disconnect_tasks.pop(user.id, None)


@bot.event
async def on_voice_state_update(member, before, after):
    print(f"Voice state update - member: {member}, before: {before.channel if before else None}, after: {after.channel if after else None}")
    if member.bot:
        return

    # ìë™ í‡´ì¥ íƒ€ì´ë¨¸ ì œê±°
    if member.id in auto_disconnect_tasks:
        auto_disconnect_tasks[member.id].cancel()
        auto_disconnect_tasks.pop(member.id, None)

    # ì…ì¥ ê¸°ë¡
    if before.channel is None and after.channel is not None:
        voice_join_times[member.id] = datetime.now(timezone.utc)

    # í‡´ì¥ ê¸°ë¡
    elif before.channel is not None and after.channel is None:
        join_time = voice_join_times.pop(member.id, None)
        if join_time:
            left_time = datetime.now(timezone.utc)
            duration = int((left_time - join_time).total_seconds())
            try:
                supabase.table("voice_activity").insert({
                    "user_id": str(member.id),
                    "username": member.display_name,
                    "joined_at": join_time.isoformat(),
                    "left_at": left_time.isoformat(),
                    "duration_sec": duration
                }).execute()
            except Exception as e:
                print(f"Supabase ì˜¤ë¥˜: {e}")

    # ë°©ì†¡ ì¢…ë£Œ ê°ì§€
    if before.self_stream and not after.self_stream and before.channel == after.channel:
        text_channel = discord.utils.get(member.guild.text_channels, name="ììœ ì±„íŒ…ë°©")
        if text_channel:
            await text_channel.send(f"ğŸ“´ {member.mention} ë‹˜ ë°©ì†¡ ì¢…ë£Œë¨")


@tasks.loop(minutes=10)
async def check_voice_channels_for_streaming():
    for guild in bot.guilds:
        text_channel = discord.utils.get(guild.text_channels, name="ììœ ì±„íŒ…ë°©")
        if not text_channel:
            continue

        for vc in guild.voice_channels:
            if vc.name in MONITORED_CHANNEL_NAMES and vc.members:
                if not any(m.voice and m.voice.self_stream for m in vc.members if not m.bot):
                    mentions = " ".join(m.mention for m in vc.members if not m.bot)
                    await text_channel.send(f"ğŸš¨ `{vc.name}` ë°©ì†¡ êº¼ì ¸ìˆìŠµë‹ˆë‹¤!\n{mentions}")


# âœ… ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´: ê²€ì‚¬
@tree.command(name="ê²€ì‚¬", description="ë‹‰ë„¤ì„ ê²€ì‚¬", guild=discord.Object(id=GUILD_ID))
async def ê²€ì‚¬(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    count = 0
    for member in interaction.guild.members:
        if member.bot:
            continue
        parts = (member.nick or member.name).split("/")
        if len(parts) != 3 or not nickname_pattern.fullmatch("/".join(p.strip() for p in parts)):
            count += 1
            try:
                await interaction.channel.send(f"{member.mention} ë‹‰ë„¤ì„ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•„ìš”.")
            except:
                pass
    await interaction.followup.send(f"ğŸ” ê²€ì‚¬ ì™„ë£Œ: {count}ëª… ë¬¸ì œ ìˆìŒ", ephemeral=True)


# âœ… ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´: ì†Œí™˜
@tree.command(name="ì†Œí™˜", description="ëª¨ë‘ ì†Œí™˜", guild=discord.Object(id=GUILD_ID))
async def ì†Œí™˜(interaction: discord.Interaction):
    vc = interaction.user.voice.channel if interaction.user.voice else None
    if not vc:
        await interaction.response.send_message("âŒ ìŒì„± ì±„ë„ì— ë“¤ì–´ê°€ì£¼ì„¸ìš”!", ephemeral=True)
        return

    moved = 0
    for other_vc in interaction.guild.voice_channels:
        if other_vc == vc:
            continue
        for member in other_vc.members:
            if not member.bot:
                try:
                    await member.move_to(vc)
                    moved += 1
                except:
                    pass
    await interaction.response.send_message(f"ğŸ“¢ {moved}ëª… ì†Œí™˜ ì™„ë£Œ!")


# âœ… ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´: íŒ€ì§œê¸°
class TeamMoveView(discord.ui.View):
    def __init__(self, teams, empty_channels, origin_channel):
        super().__init__(timeout=None)
        self.teams = teams
        self.empty_channels = empty_channels
        self.origin_channel = origin_channel
        self.moved = False

    @discord.ui.button(label="ğŸš€ íŒ€ ì´ë™ ì‹œì‘", style=discord.ButtonStyle.green)
    async def move(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.moved:
            await interaction.response.send_message("ì´ë¯¸ ì´ë™ ì™„ë£Œë¨", ephemeral=True)
            return
        for team, channel in zip(self.teams[1:], self.empty_channels):
            for member in team:
                try:
                    await member.move_to(channel)
                except:
                    pass
        self.moved = True
        button.disabled = True
        await interaction.response.edit_message(view=self)
        self.stop()


@tree.command(name="íŒ€ì§œê¸°", description="ìŒì„± ì±„ë„ íŒ€ ë‚˜ëˆ„ê¸°", guild=discord.Object(id=GUILD_ID))
@app_commands.describe(team_size="íŒ€ë‹¹ ì¸ì› ìˆ˜")
@app_commands.choices(team_size=[
    app_commands.Choice(name="2", value=2),
    app_commands.Choice(name="3", value=3),
    app_commands.Choice(name="4", value=4),
])
async def íŒ€ì§œê¸°(interaction: discord.Interaction, team_size: app_commands.Choice[int]):
    vc = interaction.user.voice.channel if interaction.user.voice else None
    if not vc:
        await interaction.response.send_message("âŒ ìŒì„± ì±„ë„ì— ë¨¼ì € ë“¤ì–´ê°€ ì£¼ì„¸ìš”!", ephemeral=True)
        return

    members = [m for m in vc.members if not m.bot]
    random.shuffle(members)
    teams = [members[i:i + team_size.value] for i in range(0, len(members), team_size.value)]

    guild = interaction.guild
    empty_channels = [ch for ch in guild.voice_channels if ch.name.startswith("ì¼ë°˜") and len(ch.members) == 0 and ch != vc]

    if len(empty_channels) < len(teams) - 1:
        await interaction.response.send_message("âŒ ë¹ˆ ì±„ë„ ë¶€ì¡±", ephemeral=True)
        return

    msg = f"ğŸ² íŒ€ ë‚˜ëˆ„ê¸° ì™„ë£Œ\n\n**íŒ€ 1 (í˜„ì¬ ì±„ë„):** {', '.join(m.display_name for m in teams[0])}\n"
    for idx, (team, ch) in enumerate(zip(teams[1:], empty_channels), start=2):
        msg += f"**íŒ€ {idx} ({ch.name}):** {', '.join(m.display_name for m in team)}\n"

    await interaction.response.send_message(msg, view=TeamMoveView(teams, empty_channels, vc))


# âœ… ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´: ë°¥
@tree.command(name="ë°¥", description="ë°¥ì¢€ë¬µê² ìŠµë‹ˆë‹¤ ì±„ë„ë¡œ ì´ë™", guild=discord.Object(id=GUILD_ID))
async def ë°¥(interaction: discord.Interaction):
    user = interaction.user
    guild = interaction.guild
    vc = discord.utils.get(guild.voice_channels, name="ë°¥ì¢€ë¬µê² ìŠµë‹ˆë‹¤")
    if not vc:
        await interaction.response.send_message("âŒ ì±„ë„ ì—†ìŒ", ephemeral=True)
        return
    try:
        await user.move_to(vc)
        await interaction.response.send_message("ğŸš ë°¥ ì±„ë„ë¡œ ì´ë™ ì™„ë£Œ", ephemeral=True)

        task = asyncio.create_task(auto_disconnect_after_timeout(user, vc, timeout=1200))
        auto_disconnect_tasks[user.id] = task
    except:
        await interaction.response.send_message("âŒ ì´ë™ ì‹¤íŒ¨", ephemeral=True)


# â€”â€”â€” ì—¬ê¸°ë¶€í„° ì¶”ê°€ â€”â€”â€”
def format_duration(seconds: int) -> str:
    days, remainder = divmod(seconds, 86400)  # 86400ì´ˆ = 1ì¼
    hours, remainder = divmod(remainder, 3600)
    minutes, seconds = divmod(remainder, 60)

    parts = []
    if days > 0:
        parts.append(f"{days}ì¼")
    if hours > 0 or days > 0:
        parts.append(f"{hours}ì‹œê°„")
    if minutes > 0 or hours > 0 or days > 0:
        parts.append(f"{minutes}ë¶„")
    parts.append(f"{seconds}ì´ˆ")

    return " ".join(parts)


@tree.command(name="ì ‘ì†ì‹œê°„ë­í‚¹", description="ìŒì„± ì ‘ì†ì‹œê°„ Top 10", guild=discord.Object(id=GUILD_ID))
async def ì ‘ì†ì‹œê°„ë­í‚¹(interaction: discord.Interaction):
    try:
        # ì‘ë‹µ ì§€ì—°(ë¡œë”© í‘œì‹œ) - ephemeral True ì˜µì…˜ ì¶”ê°€ ê°€ëŠ¥
        await interaction.response.defer()

        response = supabase.rpc("get_top_voice_activity").execute()

        if response.error:
            await interaction.followup.send(f"Supabase ì˜¤ë¥˜: {response.error.message}")
            return

        data = response.data
        if not data:
            await interaction.followup.send("ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return

        msg = "ğŸ¤ ìŒì„± ì ‘ì†ì‹œê°„ Top 10\n"
        for rank, info in enumerate(data, 1):
            time_str = format_duration(info['total_duration'])
            msg += f"{rank}. {info['username']} â€” {time_str}\n"

        await interaction.followup.send(msg)

    except Exception as e:
        try:
            await interaction.followup.send(f"ì˜¤ë¥˜ ë°œìƒ: {e}")
        except:
            # interactionì´ ì´ë¯¸ ë§Œë£Œëìœ¼ë©´ ì—¬ê¸°ì„œ ë¬´ì‹œ
            pass









@bot.event
async def on_ready():
    guild = discord.Object(id=GUILD_ID)
    await tree.sync(guild=guild)
    check_voice_channels_for_streaming.start()
    print(f"âœ… ë´‡ ë¡œê·¸ì¸: {bot.user}")


keep_alive()

TOKEN = os.getenv("DISCORD_TOKEN")
if TOKEN:
    bot.run(TOKEN)
else:
    print("âŒ í™˜ê²½ë³€ìˆ˜ DISCORD_TOKENì´ ì—†ìŠµë‹ˆë‹¤.")
